user  root;
worker_processes 1;
daemon off;
error_log /var/log/nginx/error.log debug;

pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
	lua_code_cache off;
	lua_package_path '/home/github/tengcdn/lualib/?.lua;;';
	lua_package_cpath '/home/github/tengcdn/lualib/?.so;;';

	lua_shared_dict blocked_iplist 5m;
    lua_shared_dict settings 5m;
    lua_shared_dict wsettings 5m;
    lua_shared_dict locked 1m;
    lua_shared_dict listener_init 1m;
    
    add_header  X-Cache "$upstream_cache_status from DYN";
    proxy_cache_path  /data/proxy_cache  levels=1:2   keys_zone=pcache:200m inactive=1d max_size=30g;
	proxy_set_header X-Real-IP $remote_addr;
	proxy_set_header X-Forwarded-For $remote_addr; 

	client_max_body_size 100M;
	
    lua_socket_log_errors off;

    access_by_lua '
        local blocks = ngx.shared.blocked_iplist;
        if (blocks:get(ngx.var.remote_addr)~=nil) then
            if (blocks:get(ngx.var.remote_addr) >= ngx.now()) then
                ngx.exit(444)
            end
        end
    ';
       
    init_worker_by_lua '
        set_config = function(hostname,sett)
        	ngx.log(ngx.DEBUG,"sett" .. sett)
            local dyups = require "ngx.dyups"
            local cjson = require "cjson"
            local dopairs = pairs
            local tmpkv = {}
            local gsett = cjson.decode(sett)
            if gsett ~= nil then
		        for k,v in dopairs(gsett) do
		            if (k=="upstream") then
		                local status,rv = dyups.update(hostname, v)
		                ngx.log(ngx.DEBUG,"-----" ..hostname.. "------")
		                ngx.log(ngx.DEBUG,status)
		            elseif k=="server_type" then
		                if v==1 then
		                    ngx.log(ngx.DEBUG,"got a wildcard domain set")
		                    ngx.shared.wsettings:set(gsett["wildname"],hostname)
		                end
		            else
		                tmpkv[k]=v
		            end
		        end
            	ngx.shared.settings:set(hostname,cjson.encode(tmpkv))
            else
            	ngx.log(ngx.ERR, "get sett empty")
            end
            
        end
        load_config = function(premature)
            if ngx.shared.locked:get("locked")~=1 then
                ngx.shared.locked:set("locked",1)
                ngx.timer.at(1,unlock_lock) -- will be unlock setting lock in 1 sec
                ngx.log(ngx.DEBUG,"read configures by stand alone. "..ngx.worker.pid())
                local redis = require "resty.redis"
                local red = redis:new()
                local ok,err = red:connect("127.0.0.1",6379)
                if not ok then
                    ngx.log(ngx.ERR,err)
                end
                -- add configs from redis to shm
                ngx.log(ngx.DEBUG,"connected to redis done")
                local sites = red:keys("site_*")
                if sites then
                    for _,host in ipairs(sites) do
                        local hostname = string.sub(host,6)
                        local sett = red:get(host)
                        set_config(hostname,sett)
                    end
                end
                ngx.log(ngx.DEBUG,"-----conf done-----")
                if ngx.shared.listener_init:get("started")~=1 then
                    listen_looper()
                end
            end
        end
        listen_looper = function()
            ngx.shared.listener_init:set("started",1)
            while true do
                local stat,err = listen_config()
                if err then
                end
            end
        end
        unlock_lock = function(p)
            ngx.shared.locked:set("locked",0)
        end
        listen_config = function()
            local cjson = require "cjson"
            local redis = require "resty.redis"
            local red = redis:new()
            red:set_timeout(60000)
            local ok,err = red:connect("127.0.0.1",6379)
            if not ok then
                ngx.log(ngx.ERR,err)
            end
            red:subscribe("ngx.ConfigEvent")
            while true do
                local msg, err = red:read_reply()
                if not msg then
                    return ngx.log(ngx.ERR,"ERR:"..err)
                end
                ngx.log(ngx.DEBUG, "redis reply: " .. cjson.encode(msg))
                tmsg = cjson.decode(msg[3])
                hostname = tmsg["hostname"]
                sett = tmsg["sett"]
                set_config(hostname,cjson.encode(sett))
            end
            return true
        end
        ngx.timer.at(0, load_config)
    ';       
	server {
		listen 8001;
		listen 80;
		#server_name ~^(www\.)(?<domain>.+)$;
		#server_name ~(?<domain>.+)$;

    	proxy_cache pcache;                         # proxy_cache must here
	    proxy_cache_key $scheme://$hostgroup$uri$is_args$args;     # proxy_cache_key must here		
		
		location @dyup_init {
        	dyups_interface;
    	}		
		location / {
		    set $gzip_flag "on";
		    set $hostgroup "";
            
		    rewrite_by_lua '
		        local cjson = require "cjson"
		        local settings = ngx.shared.settings
		        local wildlist = ngx.shared.wsettings
		        local sets = {}
		        if (settings:get(ngx.var.host)==nil) then

		            for _, k in pairs(wildlist:get_keys()) do
		                local from, to, err = ngx.re.find(ngx.var.host,k)
		                if from then
		                    ngx.var.hostgroup = wildlist:get(k)
		                    sets = cjson.decode(settings:get(ngx.var.hostgroup))
		                else
		                    if err then
		                        ngx.log(ngx.ERR,"Match ERR! "..err)
		                    end
		                    ngx.exit(502)
		                end
		            end

		        else
		            ngx.var.hostgroup = ngx.var.host
		            sets = cjson.decode(settings:get(ngx.var.host))
		        end

		        if (sets["gzip"]=="off") then
		            ngx.var.gzip_flag = "off"
		        end
		    ';


		     if ( $gzip_flag = "off" ) { gzip off; }

		     proxy_pass http://$hostgroup;
		     #proxy_cache_valid  200 304 30s;
		     #proxy_set_header X-Forwarded-For  $remote_addr;
		     
            header_filter_by_lua '
               local http_cache = require "http_cache"
               local cache_status = (ngx.var.upstream_cache_status or "")

               if cache_status == "MISS" or cache_status == "EXPIRED" then
                   local cache_data = http_cache.get_metadata()
                   local new_expire = ngx.time() + 5

                   if cache_data and cache_data["valid_sec"] then
                       http_cache.set_metadata({ valid_sec = new_expire,
                                                 fcn = { valid_sec = new_expire,
                                                     expire = new_expire } })
                   end
               end
            ';		     
		}
	}
}
