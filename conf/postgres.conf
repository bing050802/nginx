user  root;
worker_processes 2;
daemon off;
error_log stderr warn;

pid /var/run/nginx.pid;

events {
    worker_connections 10240;
}
worker_rlimit_nofile 30000;

http {
	lua_code_cache on;
	lua_package_path '/home/github/tengcdn/lualib/?.lua;;';
	lua_package_cpath '/home/github/tengcdn/lualib/?.so;;';
    lua_shared_dict itesty_limit 100k;
    lua_shared_dict ip_blacklist 10m;
    lua_shared_dict ip_whitelist 10m;
    lua_shared_dict req_metrics 10m;	
    lua_shared_dict req_iplist 10m;
    
    lua_shared_dict upstream_cached 100m;
    
    lua_shared_dict settings 250m;
    lua_shared_dict cached 100m;
    lua_shared_dict locked 100k;

	proxy_cache pcache;
	proxy_cache_path  /data/proxy_cache  levels=1:2   keys_zone=pcache:10m inactive=1d max_size=10m use_temp_path=off inactive=180m;
    proxy_cache_lock on;
    proxy_cache_min_uses 1;
    proxy_cache_revalidate on;
    proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
	resolver 1.2.4.8; 

       proxy_redirect off;
       proxy_set_header Host $http_host;
       proxy_set_header X-Real-IP $remote_addr;
       proxy_set_header X-Forwarded-For $remote_addr;

    init_by_lua_block {
		local config = require "cdn.config"
		config:set("log.status", true)
		config:set("log.level", 1)
		
		local logger = require "resty.logger"
		local log = logger:open("/tmp/cdn.log")
		log:set_level(0)
		config:set("log.file", log)
		config:set("db.tld", "/home/github/tengcdn/script/effective_tld_names.dat")
		t = require "cdn.tlds"
    }
    	
    init_worker_by_lua_block {
    	local worker = require "cdn.worker"
    	worker:start({
        	interval = 3,
    	})
    }
        	    

	
	upstream default {
		server 127.0.0.1:81; server 127.0.0.1:82;
	}
	
    server {
        listen 80;
        set $ups "default";
	set $ups_scheme "http";
		location / {
            proxy_pass $ups_scheme://$ups;
			add_header  X-Cache "$upstream_cache_status from DYN";

	
			rewrite_by_lua_block {
				local rewrite = require "cdn.rewrite"
				rewrite:bootstrap()
			}
			
			header_filter_by_lua_block {
				local header = require "cdn.header"
				header:bootstrap()
			}
        }
        
        location @dyup_init {
        	dyups_interface;
    	}           
    }
    server {
        listen 82;
        location / {
            return 200 "82";
        }
    }
        
    server {
        listen 81;

    	
        location / {
			return 200 "81";
        }
        location /t1 {
			content_by_lua_block {
				local settings = ngx.shared.settings
				local ok, err = settings:add("localhost", true)
				ngx.say(ok)
				local ok, err = settings:add("localhost", true)
				ngx.say(ok)

				ngx.say(t:domain("aasdf.asdfsd.com.cn"))
			}        
        }

		location /t3 {
	        content_by_lua_block {
        		local config = require "cdn.config"
				local cjson = require "cjson"
				ngx.say(cjson.encode(config:get("hostcfg")))
			}
		}
        
        location /loadall {
        	content_by_lua_block {
        		local db = require "cdn.postgres"
        		local time = require "cdn.time"
        		local cjson = require "cjson"
        		local settings = ngx.shared.settings
        		local t0 = time.gettimeofday()
        		
        		local ok, res = db:query_row("select max(id),count(id) from config.server")
        		if not ok then
        			ngx.say(res)
        		end
        		ngx.say("max=" .. res.max .. "count=" .. res.count)
        		local max_id = 5000000
        		local offset = 0
        		local limit = 2500
        		local t1 = time.gettimeofday()
        		while offset <= res.count do
					local ok, res = db:query("SELECT * FROM config.server where id<= " .. max_id .. " order by id asc limit " .. limit .. " offset " .. offset)
					if not ok or #res == 0 then
						break
					end
					local i
					for i=1, #res do
						local s = res[i]
						local setting = cjson.encode(s.setting)
						settings:set(s.servername , setting)
					end
					offset = offset + #res
					res = nil
        		end

				local t2 = time.gettimeofday() - t1 
				db:close()
				ngx.say("load config: " .. offset .. " time: " .. t2/1000 .. "ms")

        		ngx.say("load all ok")
        	}
        }

		location /pgmoon {
        	content_by_lua_block {
				local pgmoon = require("pgmoon")
				local pg = pgmoon.new({
				  host = "127.0.0.1",
				  port = "5432",
				  database = "cdn",
				  user = "postgres",
				  password = "admin"
				})
				
				assert(pg:connect())

        		local db = require "cdn.postgres"
        		local time = require "cdn.time"
        		local cjson = require "cjson"
        		local settings = ngx.shared.settings
        		local t1 = time.gettimeofday()
        		
        		local res = assert(pg:query("SELECT * FROM config.server where id<= 1000 order by id asc limit 2500 offset 0"))

				local t2 = time.gettimeofday() - t1 
				ngx.say("load config: " .. cjson.encode(res) .. " time: " .. t2/1000 .. "ms")

        		ngx.say("load all ok")
        	}
		}
        location /t2 {
			content_by_lua_block {
				local s = "1.2.com.cn"
				local i1 = 1
				local re = "%."
				 while true do
				 	i3 = i1
					local i2 = s:find(re, i1)
					if not i2 then
						break
					end
					i1 = i2 + 1
					ngx.say( "i2=", i2, "i3=", s:sub(i3, i2-1) , "   ", s:sub(i1))
					
				end
			}         
        }
        
        location /test {
			content_by_lua_block {
				local test = require "cdn.test"
				test.version()
				ngx.say("done")
			} 
        }

    }

    server {
        listen 443 ssl;
        ssl on;
        server_name _;
        set $ups "default";
	set $ups_scheme "http";
        ssl_session_cache  builtin:1000  shared:SSL:10m;
        ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers HIGH:!aNULL:!eNULL:!EXPORT:!CAMELLIA:!DES:!MD5:!PSK:!RC4;
        ssl_prefer_server_ciphers on;
        lua_ssl_trusted_certificate "/home/github/tengcdn/conf/ssl/rootCA.pem";
        ssl_certificate /home/github/tengcdn/conf/ssl/test.crt;
        ssl_certificate_key /home/github/tengcdn/conf/ssl/test.key;
		access_by_lua_block {
			require "cdn.access"
		}

		rewrite_by_lua_block {
			local rewrite = require "cdn.rewrite"
			rewrite:bootstrap()
		}
		
		header_filter_by_lua_block {
			local header = require "cdn.header"
			header:bootstrap()
		}

        ssl_certificate_by_lua_block {
        	local ssl = require "cdn.ssl"
        	ssl:bootstrap()
        }

        location / {
            proxy_ssl_verify off;
            proxy_set_header Host $host;
            proxy_pass_header Server;
            proxy_pass $ups_scheme://$ups;
        }         
    }    
}
